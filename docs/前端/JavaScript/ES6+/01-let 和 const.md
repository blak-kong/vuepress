<font size=4>
>这里结合ES5.1的变量声明方式var和function理解

## 关于 let 与 var

在 JavaScript 中，创建一个变量，会分为两个步骤。

第一步声明，第二步定义。

- 在 ES5.1 中存在变量提升`var`
  - var 在预解释的时候，会首先把变量声明，但是并不会定义
  - function 在预解释的时候，会首先把函数声明同时加定义
  - 在全局作用域下，使用 var 和 function 声明的变量会给 window 增加属性

```
console.log(test) // 不会报错

var test; // 声明
test = 1; // 定义（赋值）
```

- 在 ES6 中不允许使用变量提升`let`
  - let 没有变量提升，因此使用 console 打印，并不会提示 undefined，而是直接报错
  - 在使用 var 时，可以将已经声明的变量再次声明，而在 let 声明后，再次声明是不允许的
  - 不会给 window 增加属性，使用 in 来检测 window 的属性，是检测不到的，甚至，window 对象都被允许打印出来

```javascript
console.log(a); // 报错  let不允许变量提升
let a = 1;
```

- const 在 ES6 中

  - 同 let 类似：没有变量提升，不可以重复声明，不会给 window 增加属性
  - 同时，const 定义的是常量，var 和 let 声明变量后，可以不赋值，但是 const 必须声明的时候就定义
  - var 和 let 在声明和定以后，可以赋新值，但是 const 不允许再赋值。因为它是一个常量
  - 注：必须要赋值；若是赋值的是一个指针，那么永远是一个指针。指向的空间内的数据，是可以发生改变的，但是指向不变。

## JavaScript 中的块级作用域

我们一般认为 JavaScript 中没有块级作用域，只有函数作用域。

但**准确的说，只是 var 声明的变量没有块级作用域。**

因为**用 var 声明的变量，只能是函数作用域或者全局作用域。**

而 `let` 和 `const` 声明的变量，存在块级作用域。

> {},就是一个块级作用域，块级作用域下 var 和 function 声明的变量依然是全局的。

> 即在块级作用域外面是可以访问的 但是块级作用域下 let 和 const 声明的变量是私有的，在外面是获取不到的。

- 不能在行首直接写{name:"Cyan",age:19}，这样写会报错，因为它们被当做成块级作用域

```
- let obj = {name:"Cyan",age:19};
- ({name:"Aqing",age:20})
这两种方式都可以声明对象，而不是被当做块级作用域
```

#### if 中的块级作用域：

if 语句中的 function 只会提前声明，并不会同时定义，它的定义发生在 if 判断为真的时候，进入 if 作用域的第一件事就是，给 function 赋值，代码再执行

#### for 循环中的块级作用域：

使用 var 声明的 for 循环中的循环值，在循环外是可以访问到的，也就是说，这个值是全局的。

同时，这个值在外面访问时，是已经步长累加完的值。

使用 let 声明的 for 循环中的循环值，因为是属于块级作用域私有的，所以循环体外是访问不到的。
