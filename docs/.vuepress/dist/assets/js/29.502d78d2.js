(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{204:function(t,a,v){"use strict";v.r(a);var s=v(6),n=Object(s.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("font",{attrs:{size:"4"}},[t._v("\n>这里结合ES5.1的变量声明方式var和function理解\n"),v("h2",{attrs:{id:"关于-let-与-var"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#关于-let-与-var"}},[t._v("#")]),t._v(" 关于 let 与 var")]),t._v(" "),v("p",[t._v("在 JavaScript 中，创建一个变量，会分为两个步骤。")]),t._v(" "),v("p",[t._v("第一步声明，第二步定义。")]),t._v(" "),v("ul",[v("li",[t._v("在 ES5.1 中存在变量提升"),v("code",[t._v("var")]),t._v(" "),v("ul",[v("li",[t._v("var 在预解释的时候，会首先把变量声明，但是并不会定义")]),t._v(" "),v("li",[t._v("function 在预解释的时候，会首先把函数声明同时加定义")]),t._v(" "),v("li",[t._v("在全局作用域下，使用 var 和 function 声明的变量会给 window 增加属性")])])])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("console.log(test) // 不会报错\n\nvar test; // 声明\ntest = 1; // 定义（赋值）\n")])])]),v("ul",[v("li",[t._v("在 ES6 中不允许使用变量提升"),v("code",[t._v("let")]),t._v(" "),v("ul",[v("li",[t._v("let 没有变量提升，因此使用 console 打印，并不会提示 undefined，而是直接报错")]),t._v(" "),v("li",[t._v("在使用 var 时，可以将已经声明的变量再次声明，而在 let 声明后，再次声明是不允许的")]),t._v(" "),v("li",[t._v("不会给 window 增加属性，使用 in 来检测 window 的属性，是检测不到的，甚至，window 对象都被允许打印出来")])])])]),t._v(" "),v("div",{staticClass:"language-javascript extra-class"},[v("pre",{pre:!0,attrs:{class:"language-javascript"}},[v("code",[t._v("console"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("log")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("a"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 报错  let不允许变量提升")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("let")]),t._v(" a "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("1")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])])]),v("ul",[v("li",[v("p",[t._v("const 在 ES6 中")]),t._v(" "),v("ul",[v("li",[t._v("同 let 类似：没有变量提升，不可以重复声明，不会给 window 增加属性")]),t._v(" "),v("li",[t._v("同时，const 定义的是常量，var 和 let 声明变量后，可以不赋值，但是 const 必须声明的时候就定义")]),t._v(" "),v("li",[t._v("var 和 let 在声明和定以后，可以赋新值，但是 const 不允许再赋值。因为它是一个常量")]),t._v(" "),v("li",[t._v("注：必须要赋值；若是赋值的是一个指针，那么永远是一个指针。指向的空间内的数据，是可以发生改变的，但是指向不变。")])])])]),t._v(" "),v("h2",{attrs:{id:"javascript-中的块级作用域"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#javascript-中的块级作用域"}},[t._v("#")]),t._v(" JavaScript 中的块级作用域")]),t._v(" "),v("p",[t._v("我们一般认为 JavaScript 中没有块级作用域，只有函数作用域。")]),t._v(" "),v("p",[t._v("但"),v("strong",[t._v("准确的说，只是 var 声明的变量没有块级作用域。")])]),t._v(" "),v("p",[t._v("因为"),v("strong",[t._v("用 var 声明的变量，只能是函数作用域或者全局作用域。")])]),t._v(" "),v("p",[t._v("而 "),v("code",[t._v("let")]),t._v(" 和 "),v("code",[t._v("const")]),t._v(" 声明的变量，存在块级作用域。")]),t._v(" "),v("blockquote",[v("p",[t._v("{},就是一个块级作用域，块级作用域下 var 和 function 声明的变量依然是全局的。")])]),t._v(" "),v("blockquote",[v("p",[t._v("即在块级作用域外面是可以访问的 但是块级作用域下 let 和 const 声明的变量是私有的，在外面是获取不到的。")])]),t._v(" "),v("ul",[v("li",[t._v('不能在行首直接写{name:"Cyan",age:19}，这样写会报错，因为它们被当做成块级作用域')])]),t._v(" "),v("div",{staticClass:"language- extra-class"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v('- let obj = {name:"Cyan",age:19};\n- ({name:"Aqing",age:20})\n这两种方式都可以声明对象，而不是被当做块级作用域\n')])])]),v("h4",{attrs:{id:"if-中的块级作用域："}},[v("a",{staticClass:"header-anchor",attrs:{href:"#if-中的块级作用域："}},[t._v("#")]),t._v(" if 中的块级作用域：")]),t._v(" "),v("p",[t._v("if 语句中的 function 只会提前声明，并不会同时定义，它的定义发生在 if 判断为真的时候，进入 if 作用域的第一件事就是，给 function 赋值，代码再执行")]),t._v(" "),v("h4",{attrs:{id:"for-循环中的块级作用域："}},[v("a",{staticClass:"header-anchor",attrs:{href:"#for-循环中的块级作用域："}},[t._v("#")]),t._v(" for 循环中的块级作用域：")]),t._v(" "),v("p",[t._v("使用 var 声明的 for 循环中的循环值，在循环外是可以访问到的，也就是说，这个值是全局的。")]),t._v(" "),v("p",[t._v("同时，这个值在外面访问时，是已经步长累加完的值。")]),t._v(" "),v("p",[t._v("使用 let 声明的 for 循环中的循环值，因为是属于块级作用域私有的，所以循环体外是访问不到的。")])])],1)}),[],!1,null,null,null);a.default=n.exports}}]);