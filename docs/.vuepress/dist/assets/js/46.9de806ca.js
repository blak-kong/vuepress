(window.webpackJsonp=window.webpackJsonp||[]).push([[46],{223:function(t,a,v){"use strict";v.r(a);var e=v(6),s=Object(e.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h2",{attrs:{id:"栈-堆"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#栈-堆"}},[t._v("#")]),t._v(" 栈&堆")]),t._v(" "),v("h3",{attrs:{id:"栈和队列的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#栈和队列的区别"}},[t._v("#")]),t._v(" 栈和队列的区别?")]),t._v(" "),v("p",[t._v("栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。\n队列先进先出，栈先进后出。\n栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除")]),t._v(" "),v("h3",{attrs:{id:"栈和堆的区别？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#栈和堆的区别？"}},[t._v("#")]),t._v(" 栈和堆的区别？")]),t._v(" "),v("p",[t._v("栈区（stack）— 内存大小固定，存储基本类型数据，由编译器自动分配释放，运行速度快。后进先出。\n堆区（heap） — 内存大小不固定，存储引用类型数据，由程序员分配释放，若程序员不释放，程序结束时可能由垃圾收集器回收。")]),t._v(" "),v("p",[t._v("栈（数据结构）：一种先进后出的数据结构。\n堆（数据结构）：堆是在程序运行时，而不是在程序编译时，申请某个大小的内存空间（动态分配内存）。其访问和对一般内存的访问没有区别。")]),t._v(" "),v("h2",{attrs:{id:"eventloop-宏任务和微任务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#eventloop-宏任务和微任务"}},[t._v("#")]),t._v(" EventLoop 宏任务和微任务")]),t._v(" "),v("p",[t._v("执行顺序：")]),t._v(" "),v("ul",[v("li",[t._v("js 引擎会使用解释器去对源代码进行词法分析，构建成抽象语法树，然后再执行。")]),t._v(" "),v("li",[t._v("js 会先执行全局函数作用域中的所有同步任务，期间遇到异步任务，会按顺序放入任务队列。")]),t._v(" "),v("li",[t._v("假如同步任务的执行过程（局部函数作用域）中调用了异步任务，会优先执行同步任务中的异步（上下文环境不同，会开启一个局部任务队列，但相对于父级的执行栈，该任务\n仍旧是同步任务）。")]),t._v(" "),v("li",[t._v("每次准备去执行第一个宏任务前，都要将所有的微任务一个一个取出来执行")]),t._v(" "),v("li",[t._v("对于 then 的链式调用，只有当前 then 的上一个 then 执行完毕之后，当前 then 才会被加入微任务队列")])]),t._v(" "),v("p",[t._v("执行栈的执行顺序：同步函数 => 微队列 => 宏队列")]),t._v(" "),v("h3",{attrs:{id:"微任务和宏任务的区别？"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#微任务和宏任务的区别？"}},[t._v("#")]),t._v(" 微任务和宏任务的区别？")]),t._v(" "),v("p",[t._v("微任务和宏任务一样都是异步任务队列。微任务是局部函数作用域的队列，宏任务是全局作用域的队列。")]),t._v(" "),v("p",[t._v("因为 JavaScript 存在函数作用域，所以当执行栈进入到同步函数内部，就进入了一个新的执行上下文环境。")])])}),[],!1,null,null,null);a.default=s.exports}}]);