---
title: js事件循环
---

## 前言

在解释事件循环之前首先先解释一下浏览器的执行线程：

浏览器是多进程的，浏览器每一个 tab 标签都代表一个独立的进程，其中浏览器渲染进程（浏览器内核）属于浏览器多进程中的一种，主要负责页面渲染，脚本执行，事件处理等。

其包含的线程有：GUI 渲染线程（负责渲染页面，解析 HTML，CSS 构成 DOM 树）、JS 引擎线程、事件触发线程、定时器触发线程、http 请求线程等主要线程

关于执行中的线程：

主线程 js 引擎执行的线程，这个线程只有一个，主要负责处理 Javascript 脚本程序，例如 V8 引擎。

工作线程：也称幕后线程，这个线程存在于浏览器，与主线程是分开的，处理文件读取、网络请求等异步事件。

详情点击链接跳转 👉[浏览器进程？线程？傻傻分不清楚！ - 腾讯 Web 前端 IMWeb 团队社区](https://imweb.io/topic/58e3bfa845e5c13468f567d5)

## 任务队列

JavaScript 中所有的任务都可以分为同步任务和异步任务。

- 同步任务，顾名思义，就是立即执行的任务，同步任务一般会直接进入到主线程中执行；
- 异步任务，就是异步执行的任务，比如 ajax 网络请求，setTimeout 定时函数等都属于异步任务。

**异步任务会通过任务队列的机制(先进先出的机制)来进行协调。**

具体流程用下面的图来说明：

![事件循环](https://pic1.zhimg.com/80/v2-1337770fcc29d10325ee4eb127496fff_720w.jpg)

### 任务队列中的任务何时进入主线程？

![队列](https://hexo-blog-1256114407.cos.ap-shenzhen-fsi.myqcloud.com/executionContext2.jpg)

这里分成三个步骤解释：

1、所有同步任务都在主线程上执行，形成一个执行栈

2、执行栈之外，还存在一个"消息队列"。只要异步操作执行完成，就到消息队列中排队等待回调

3、一旦执行栈中的所有同步任务执行完毕，系统就会按次序读取消息队列中的异步任务，于是被读取的异步任务结束等待状态，进入执行栈，开始执行

4、主线程不断重复上面的第三步

## 微任务与宏任务的概念

微任务常用面试题

```
setTimeout(_ => console.log(4))

new Promise(resolve => {
  resolve()
  console.log(1)
}).then(_ => {
  console.log(3)
})

console.log(2)

// 1 2 3 4
```

**为什么第一个 setTimeout 最后执行？**

因为宏任务直接进入任务队列，而 Promise 实际上是微任务。

**Promise 真的是微任务吗？它的 `then()` 方法是异步宏任务？**

Promise 的 `then()` 方法内部确实存在  
异步任务，但

promise 函数在尾调用 `then()` 前的代码是微任务，所以会同步执行。

### 微任务

同步：Promise、process.nextTick（node 环境）、Object.observe, MutationObserver

### 宏任务

异步：setTimeout、setInterval、XMLHttprequest、setImmediate、I/O、UI rendering

## 总结

浏览器执行的顺序：

- (1)执行主代码块
- (2)若遇到 Promise，把 then 之后的内容放进微任务队列
- (3)遇到 setTimeout，把他放到宏任务里面
- (4)一次宏任务执行完成，检查微任务队列有无任务
- (5)有的话执行所有微任务
- (6)执行完毕后，开始下一次宏任务。

文章很短，但知识点不会很复杂。复杂的是实际应用场景。
